"""
Core Data Structures for AI-Trader

This module defines the standardized data structures used throughout the trading system.
These dataclasses ensure type safety and consistent data flow between components.
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, List, Literal, Optional
import uuid


class SignalDirection(str, Enum):
    """Trading signal direction."""
    LONG = "LONG"
    SHORT = "SHORT"
    NEUTRAL = "NEUTRAL"


class OrderType(str, Enum):
    """Order type for execution."""
    MARKET = "MARKET"
    LIMIT = "LIMIT"
    STOP_LIMIT = "STOP_LIMIT"
    STOP_MARKET = "STOP_MARKET"


class OrderStatus(str, Enum):
    """Order lifecycle states."""
    CREATED = "CREATED"
    PENDING = "PENDING"
    PARTIAL = "PARTIAL"
    FILLED = "FILLED"
    REJECTED = "REJECTED"
    CANCELLED = "CANCELLED"
    EXPIRED = "EXPIRED"


class RiskAction(str, Enum):
    """Risk engine actions when circuit breakers trigger."""
    NORMAL = "NORMAL"  # No action needed
    REDUCE_SIZE = "REDUCE_SIZE"  # Reduce position sizes by 50%
    HALT_NEW = "HALT_NEW"  # Halt new positions, allow exits
    FORCE_LIQUIDATE = "FORCE_LIQUIDATE"  # Force liquidate to target cash
    KILL_SWITCH = "KILL_SWITCH"  # Emergency stop all trading


class Regime(str, Enum):
    """Market regime classification."""
    TRENDING_UP = "TRENDING_UP"
    TRENDING_DOWN = "TRENDING_DOWN"
    RANGING = "RANGING"
    VOLATILE = "VOLATILE"
    UNKNOWN = "UNKNOWN"


@dataclass
class MarketState:
    """
    Represents the current state of a market/asset at a specific point in time.

    This is the primary input data structure for trading agents.
    """
    timestamp: datetime
    symbol: str

    # OHLCV data
    open: float
    high: float
    low: float
    close: float
    volume: float

    # Technical indicators (calculated separately)
    technical_indicators: Dict[str, float] = field(default_factory=dict)
    # Common indicators: RSI, MACD, MACD_signal, MACD_hist,
    # BB_upper, BB_middle, BB_lower, ATR, ADX, SMA_20, SMA_50, EMA_12, EMA_26

    # On-chain metrics (crypto only)
    on_chain_metrics: Dict[str, float] = field(default_factory=dict)
    # Crypto metrics: MVRV, SOPR, exchange_net_flow, whale_ratio

    # Sentiment data
    sentiment_score: Optional[float] = None  # -1 to 1
    sentiment_source: Optional[str] = None

    # Market context
    daily_volume_avg_20d: Optional[float] = None
    volatility_20d: Optional[float] = None

    @property
    def ohlcv(self) -> Dict[str, float]:
        """Return OHLCV as dictionary."""
        return {
            "open": self.open,
            "high": self.high,
            "low": self.low,
            "close": self.close,
            "volume": self.volume,
        }

    @property
    def typical_price(self) -> float:
        """Calculate typical price (HLC average)."""
        return (self.high + self.low + self.close) / 3

    @property
    def daily_range(self) -> float:
        """Calculate daily range as percentage."""
        return (self.high - self.low) / self.low * 100 if self.low > 0 else 0


@dataclass
class Signal:
    """
    A trading signal generated by a model/agent.

    Signals are the output from trading agents before risk management and execution.
    """
    timestamp: datetime
    symbol: str
    direction: SignalDirection

    # Signal strength and confidence
    strength: float  # 0-1, how strong is the signal
    confidence: float  # 0-1, calibrated probability of success

    # Position sizing
    target_position_pct: float  # Target position as % of portfolio

    # Risk management
    stop_loss: Optional[float] = None  # Stop loss price
    take_profit: Optional[float] = None  # Take profit price

    # Model metadata
    model_name: str = ""
    model_version: str = ""

    # Reasoning/explanation
    reasoning: str = ""

    # Additional context
    market_state: Optional[MarketState] = None
    regime: Optional[Regime] = None

    # Unique identifier
    id: str = field(default_factory=lambda: str(uuid.uuid4()))

    def __post_init__(self):
        """Validate signal values."""
        if not 0 <= self.strength <= 1:
            raise ValueError(f"Signal strength must be 0-1, got {self.strength}")
        if not 0 <= self.confidence <= 1:
            raise ValueError(f"Signal confidence must be 0-1, got {self.confidence}")
        if not -1 <= self.target_position_pct <= 1:
            raise ValueError(f"Target position must be -1 to 1, got {self.target_position_pct}")


@dataclass
class Position:
    """Represents a position in a single asset."""
    symbol: str
    quantity: float
    avg_entry_price: float
    current_price: float
    unrealized_pnl: float
    unrealized_pnl_pct: float
    market_value: float
    cost_basis: float
    opened_at: datetime
    last_updated: datetime

    # For T+1 markets (A-shares)
    available_to_sell: float = 0  # Quantity available to sell today

    @property
    def is_long(self) -> bool:
        return self.quantity > 0

    @property
    def is_short(self) -> bool:
        return self.quantity < 0


@dataclass
class Portfolio:
    """Represents the entire portfolio state."""
    timestamp: datetime

    # Cash and value
    cash: float
    total_value: float
    buying_power: float

    # Positions
    positions: Dict[str, Position] = field(default_factory=dict)

    # Performance metrics
    total_pnl: float = 0.0
    total_pnl_pct: float = 0.0
    daily_pnl: float = 0.0
    daily_pnl_pct: float = 0.0

    # Risk metrics
    max_drawdown: float = 0.0
    current_drawdown: float = 0.0
    peak_value: float = 0.0

    @property
    def position_count(self) -> int:
        return len(self.positions)

    @property
    def total_exposure(self) -> float:
        """Total market exposure as percentage of portfolio."""
        if self.total_value == 0:
            return 0
        return sum(abs(p.market_value) for p in self.positions.values()) / self.total_value

    def get_position_weight(self, symbol: str) -> float:
        """Get position weight as percentage of portfolio."""
        if symbol not in self.positions or self.total_value == 0:
            return 0
        return self.positions[symbol].market_value / self.total_value


@dataclass
class TargetPortfolio:
    """
    Target portfolio allocation from signal aggregation.

    This is the output of the signal aggregator, representing the desired portfolio state.
    """
    timestamp: datetime

    # Target positions (symbol -> target weight as % of portfolio)
    positions: Dict[str, float] = field(default_factory=dict)

    # Aggregated metrics
    total_exposure: float = 0.0  # Sum of absolute weights
    net_exposure: float = 0.0  # Sum of signed weights (long - short)

    # Market regime
    regime: Regime = Regime.UNKNOWN

    # Consensus metrics
    model_agreement: float = 0.0  # 0-1, how much models agree
    confidence: float = 0.0  # Weighted average confidence

    # Source signals
    source_signals: List[Signal] = field(default_factory=list)

    def __post_init__(self):
        """Calculate exposure metrics."""
        self.total_exposure = sum(abs(w) for w in self.positions.values())
        self.net_exposure = sum(self.positions.values())


@dataclass
class OrderIntent:
    """
    An intent to place an order, before execution.

    OrderIntents are validated by the risk engine before becoming actual orders.
    """
    symbol: str
    side: Literal["BUY", "SELL"]
    quantity: float
    order_type: OrderType

    # Pricing
    limit_price: Optional[float] = None
    stop_price: Optional[float] = None

    # Time in force
    time_in_force: str = "DAY"  # DAY, GTC, IOC, FOK

    # Client order ID for idempotency
    client_order_id: str = field(default_factory=lambda: str(uuid.uuid4()))

    # Source signal
    source_signal_id: Optional[str] = None

    # Timestamps
    created_at: datetime = field(default_factory=datetime.now)

    def __post_init__(self):
        """Validate order intent."""
        if self.quantity <= 0:
            raise ValueError(f"Order quantity must be positive, got {self.quantity}")
        if self.order_type == OrderType.LIMIT and self.limit_price is None:
            raise ValueError("Limit orders require a limit price")
        if self.order_type == OrderType.STOP_LIMIT and (self.limit_price is None or self.stop_price is None):
            raise ValueError("Stop-limit orders require both limit and stop prices")


@dataclass
class ExecutionReport:
    """
    Execution report for an order.

    Tracks the lifecycle and fill details of an order.
    """
    order_id: str  # Exchange-assigned order ID
    client_order_id: str  # Client-assigned ID for correlation

    # Order details
    symbol: str
    side: Literal["BUY", "SELL"]
    order_type: OrderType

    # Status
    status: OrderStatus

    # Fill details
    ordered_qty: float
    filled_qty: float
    remaining_qty: float
    avg_fill_price: float

    # Cost analysis
    slippage: float = 0.0  # Slippage as percentage
    commission: float = 0.0
    total_cost: float = 0.0  # filled_qty * avg_fill_price + commission

    # Timestamps
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    filled_at: Optional[datetime] = None

    # Error handling
    reject_reason: Optional[str] = None

    @property
    def is_complete(self) -> bool:
        """Check if order is in a terminal state."""
        return self.status in {
            OrderStatus.FILLED,
            OrderStatus.REJECTED,
            OrderStatus.CANCELLED,
            OrderStatus.EXPIRED,
        }

    @property
    def fill_rate(self) -> float:
        """Calculate fill rate as percentage."""
        if self.ordered_qty == 0:
            return 0
        return self.filled_qty / self.ordered_qty


@dataclass
class TradeRecord:
    """
    A completed trade for audit and analysis.

    Created when an order is fully or partially filled.
    """
    id: str = field(default_factory=lambda: str(uuid.uuid4()))

    # Order reference
    order_id: str = ""
    client_order_id: str = ""

    # Trade details
    symbol: str = ""
    side: Literal["BUY", "SELL"] = "BUY"
    quantity: float = 0.0
    price: float = 0.0

    # Costs
    commission: float = 0.0
    slippage: float = 0.0

    # Source
    model_name: str = ""
    signal_id: str = ""

    # Timestamp
    executed_at: datetime = field(default_factory=datetime.now)

    @property
    def notional_value(self) -> float:
        """Calculate notional value of trade."""
        return self.quantity * self.price


@dataclass
class RiskViolation:
    """Record of a risk constraint violation."""
    timestamp: datetime
    violation_type: str  # "position_limit", "sector_exposure", "daily_loss", etc.
    description: str
    current_value: float
    limit_value: float
    action_taken: RiskAction
    order_rejected: Optional[str] = None  # client_order_id if an order was rejected
